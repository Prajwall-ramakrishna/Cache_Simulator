#include <iostream>
#include <vector>
#include <list>
#include <cmath>
#include <iomanip>
using namespace std;

struct CacheLine {
    bool valid = false;
    bool dirty = false;
    unsigned int tag;
};
class CacheSimulator {
  int total_blocks;
  int block_size;
  int latency;
  bool write_back;
  bool write_allocate;
  bool exclusive_mode = false;
  list<CacheLine> cache;
  int hits = 0, misses = 0;
  int memory_writes = 0;
  
  CacheSimulator* next_level = nullptr; 
 
public:  
  CacheSimulator (int cache_size, int block_size, int latency, bool write_back = true, bool write_allocate = true){
      this->block_size = block_size;
      total_blocks = cache_size/block_size;
      this->latency = latency;
      this->write_back = write_back;
      this->write_allocate = write_allocate;
  }
  
  void setExclusive(bool mode){
      exclusive_mode = mode;
  }
  void connectLowerLevel(CacheSimulator* nextlvl_csh_ptr){
      next_level = nextlvl_csh_ptr;
  }
  
  bool access(unsigned int addr){
      int offset_bits = log2(block_size);
      unsigned int tag = addr >> offset_bits;
      
      bool hit = false;
      auto it = cache.begin();
      for (; it!=cache.end(); it++){
          if (it->valid && it->tag == tag){
              hit = true;
              break;
          }
      }
      
      if (hit){
          hits++;
          CacheLine line = *it;
          cache.erase(it);
          cache.push_back(line);
          return true;
      }
      
      misses++;
      return false;
  }
  
  bool write(unsigned int addr){
       int offset_bits = log2(block_size);
      unsigned int tag = addr >> offset_bits;
      
      bool hit = false;
      auto it = cache.begin();
      for (; it!=cache.end(); it++){
          if (it->valid && it->tag == tag){
              hit = true;
              break;
          }
      }
      
      if (hit){
          hits++;
          CacheLine line = *it;
          if (write_back){
              line.dirty = true;
          } 
          cache.erase(it);
          cache.push_back(line);
          return true;
      }
      
      misses++;
      
      if (write_allocate){
          insert(addr, true); // Inset new data and make it dirty
      } else{
          memory_writes++;  // Memory updated regardless of write-back or write-through
      }
      return false;
  }
  
  void insert(unsigned int addr, bool is_write = false){
      int offset_bits = log2(block_size);
      unsigned int tag = addr >> offset_bits;
      
      for (auto it=cache.begin(); it!=cache.end(); it++){  //Just to be sure if same tag exists before you insert remove it.
          if (it->valid && it->tag == tag){                //In our design it doesn't matter but in case of prefetching, this logic is needed.
              cache.erase(it);
              break;
          }
      }
      
      if (cache.size() >= total_blocks){
          CacheLine evicted = cache.front();
          if(evicted.valid){
              if (write_back && evicted.dirty){
                  unsigned int evicted_addr = (evicted.tag << offset_bits);
                  if (next_level) next_level->insert(evicted_addr,true);                //Is there a next level cache?
                  else memory_writes++;
              }
              if (!exclusive_mode && next_level){       //If you are evicting L1 then check if L2 has the data, if it  does then evict there also.
                  next_level->evict(evicted.tag << offset_bits);
              }
         }
          cache.pop_front();
      }
      
      if (exclusive_mode && next_level) next_level->evict(tag << offset_bits);   //If it is Exclusive mode then before inserting the new tag here,
      cache.push_back({true, write_back && is_write, tag});                      //the same tag must be removed from the higher level.
  } 
  
  void evict(unsigned int addr){
      int offset_bits = log2(block_size);
      unsigned int tag = addr >> offset_bits;
      
      for (auto it=cache.begin(); it!=cache.end(); it++){
          if(it->valid && it->tag == tag){
              cache.erase(it);
              return;
          }
      }
  }
  
  void flushAll(){
      for (auto it=cache.begin(); it!=cache.end(); it++){
          int offset_bits = log2(block_size);
          if (write_back && it->valid && it->dirty){
              unsigned int addr = it->tag << offset_bits;
              if (next_level) next_level->insert(addr,true);
              else memory_writes++;
          }
      }
  }
  
  int getAccessLatency() const{
      return latency;
  }
  
  void printStats(const string& name) const{
      cout<<"Hits: "<<hits<<" ,Misses: "<<misses<<" ,Memory_writes: "<<memory_writes<<endl;
  }
  
  void printContents(const string& name) const{
      cout << "\n" << name << " Cache Contents:\n";
        cout << left << setw(8) << "Valid" << setw(8) << "Dirty" << "Tag" << endl;
        for (const auto& line : cache) {
            if (line.valid)
                cout << setw(8) << line.valid << setw(8) << line.dirty << "0x" << hex << line.tag << dec << endl;
        }
  }
};


int main() {
    CacheSimulator L1(32,4,1);  //(cache_size,block_size,latency,write_back,write_allocate)
    CacheSimulator L2(128,4,10);
    CacheSimulator L3(512,4,50);
    
    L1.connectLowerLevel(&L2);
    L2.connectLowerLevel(&L3);
    
    // Enable inclusive or exclusive mode
    L1.setExclusive(false);   // Set to true for exclusive behavior
    L2.setExclusive(false);
    
    int total_cycles = 0;
    vector<unsigned int> reads_trace = {
        0x00, 0x04, 0x08, 0x00, 0x10,
        0x04, 0x00, 0x20, 0x10, 0x30,
        0x40, 0x50, 0x60, 0x70, 0x80,
        0x00, 0x04, 0x08, 0x0C, 0x10,
        0x14, 0x18, 0x1C, 0x00, 0x10  
    };
    
    for (auto addr : reads_trace) {
        if (!L1.access(addr)) {
            if (!L2.access(addr)){
                if(!L3.access(addr)){
                    L3.insert(addr);
                }
                L2.insert(addr);   // fetch from memory to L2
            }
            L1.insert(addr);      // bring into L1
        }
    }

    vector<unsigned int> writes_trace = {
    0x04, 0x00, 0x20, 0x10, 0xff,
    0x30, 0x40, 0x50, 0x60, 0x70 };
    for (auto addr : writes_trace) {
        L1.write(addr);  // write() already handles insert() internally if needed
    }
    
    //Final Flush
    L1.flushAll();
    L2.flushAll();
    L3.flushAll();
    
    //Report
    L1.printStats("L1");
    L2.printStats("L2");
    L3.printStats("L3");
    
    L1.printContents("L1");
    L2.printContents("L2");
    L3.printContents("L3");
    return 0;
}