#include <iostream>
#include <vector>
#include <list>
#include <cmath>
#include <bitset>
#include <unordered_set>
using namespace std;

struct CacheLine{
    bool valid = false;
    unsigned int tag;
};

class CacheSimulator{
  int cache_size;
  int block_size;
  int associativity;
  int num_sets;
  vector<list<CacheLine>> cache;
  unordered_set<unsigned int> unique_tags;
  int compulsory_misses = 0, conflict_misses = 0, capacity_misses = 0;
  int hits = 0, misses = 0;
  
public:
      CacheSimulator(int cache_size, int block_size, int associativity){
          this->cache_size = cache_size;
          this->block_size = block_size;
          this->associativity = associativity;
          num_sets = (cache_size/block_size)/associativity;
          cache.resize(num_sets);
      }
      
      void access(unsigned int addr){
          int offset_bits = log2(block_size);
          int index_bits = log2(num_sets);
          unsigned int index = (addr >> offset_bits) & ((1 << index_bits) - 1);
          unsigned int tag = (addr >> (index_bits + offset_bits));
          
          bitset<32> addr_bits(addr);
          bitset<32> tag_bits(tag);

          cout << "Accessing address: " << addr_bits
             << ", Tag: " << tag_bits
             << ", Index: " << index << endl;
          
          auto &set = cache[index];
          bool hit = false;
          
          auto it = set.begin();
          for(; it != set.end(); it++){
              if (it->valid && it->tag == tag){
                  hit = true;
                  break;
              }
          }
        //   for (auto &line: set){
        //       if (line.valid && line.tag == tag){
        //           hit = true;
        //           break;
        //       }
        //   }
          
          if (hit){
              hits++;
              CacheLine line = *it;
              set.erase(it);
              set.push_back(line);
          } else {
              misses++;
              if (unique_tags.find(tag) == unique_tags.end()){
                  compulsory_misses++;
                  unique_tags.insert(tag);
              } else {
                  if(set.size() >= associativity){
                  conflict_misses++;
              } else{
                  capacity_misses++;
              }
              }
              if (set.size() >= associativity){
                  set.pop_front();
              }
              set.push_back({true, tag});
          }
      }
      
      void printStats(){
          cout<<"Hits: "<<hits<<", Misses: "<<misses<<endl;
          cout<<"Compulsory_misses: "<<compulsory_misses<<endl;
          cout<<"Capacity_misses: "<<capacity_misses<<endl;
          cout<<"Conflict_misses: "<<conflict_misses<<endl;
      }
      
};
int main() {
    CacheSimulator sim(32,4,2);
    vector<unsigned int> trace = {
     // Fill set 0 (should trigger conflict)
    0x00, 0x10, 0x20, // all map to set 0, different tags
    0x00, 0x10, 0x30, // reaccess old (test hit or miss based on policy)

    // Fill set 1
    0x04, 0x14, 0x24,
    0x04, 0x14, 0x34,

    // Repeat some earlier addresses (test reuse)
    0x00, 0x10, 0x04, 0x14,

    // Mix of new tags in same sets to cause eviction
    0x40, 0x50, 0x60, 0x70,

    // Stress test with alternating pattern
    0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x18, 0x1C,

    // Reaccess old ones
    0x00, 0x04, 0x10, 0x14,

    // Hit/miss challenge
    0x00, 0x20, 0x10, 0x30, 0x40, 0x50,
    };
    
    for(auto addr: trace){
        sim.access(addr);
    }
    
    sim.printStats();
    return 0;
}